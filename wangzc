import multiprocessing
import Levenshtein as L
from Bio.Align import PairwiseAligner
from Bio.Align.substitution_matrices import Array
import numpy as np
import sys


def DNA_complement1(sequence):
    comp_dict = {
        "A": "T",
        "T": "A",
        "G": "C",
        "C": "G",
        "N": "N"
    }
    sequence_list = list(sequence)
    sequence_list = [comp_dict[base] for base in sequence_list]
    sequence_list.reverse()
    string = ''.join(sequence_list)
    return string
def check1(str1, str2):
    length1 = len(str1)
    length = min(length1, len(str2))
    k = max(range(0, length + 1), key=lambda i: i if L.hamming(str1[length1 - i:], str2[:i]) < i * 0.1 else False)
    return k
def check_over(read1,read2):
    lap=max(len(read2),len(read1))
    a1=check1(read1, DNA_complement1(read2))
    if a1>5:  #显著性0.0014
        lap=len(read1)-int(a1/2)
    else:
        a2 = check1(DNA_complement1(read2), read1)
        if a2 > min(len(read2),len(read1)) * 0.8 and a2>5:
            lap=len(read1)-int(a2/2)
    return lap



def process_reads(read_pair):
    name=read_pair.split()[0]
    read1=read_pair.split()[1]
    read2= read_pair.split()[2]
    aligner = PairwiseAligner()
    alphabet = "ACGTN"
    substitution_matrix = np.array([
        [1.0, 0.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0]
    ])
    matrix = Array(alphabet, 2, substitution_matrix)
    aligner.mode = 'global'
    aligner.open_gap_score = -5
    aligner.extend_gap_score = -2
    aligner.substitution_matrix = matrix
    alignments = aligner.align(read1, read2)
    r1, r2 = alignments[0][0], alignments[0][1]
    scores = [10 if (c1 == 'G' and c2 == 'G') else 1 if c1==c2 or (c1 == 'T' and c2 == 'C')else -10 for c1, c2 in zip(r1, r2)]
    max_index = max(range(len(scores)), key=lambda i: sum(scores[:i + 1])) + 1
    result = [c1 if c1 == c2  else c2 if c1 == 'T' and c2 == 'C' else 'N' for c1, c2 in
              zip(r1[:max_index], r2[:max_index])]
    mid_pos=check_over(read1,read2)
    if len(result) > mid_pos:
        if "G" in result[mid_pos - 20:]:
            result = result[:-result[::-1].index("G")]
        else:
            result = result[:mid_pos - 20]
    if len(result)==0:
        result.append("N")
    return name + " " + "".join(result)



    # if "T" in result[-10:] and len(result)>34:
    #     final = result[:-result[::-1].index("T") - 1]
    #     return name+" "+"".join(final)
    # else:
    #     return name+" "+"".join(result)



if __name__ == '__main__':
    if len(sys.argv) != 5:
        print("Usage: python your_script.py f1.fq f2.fq out.txt processes")
        sys.exit(1)

    # 从命令行参数获取文件名和进程数
    f1_filename = sys.argv[1]
    f2_filename = sys.argv[2]
    out_filename = sys.argv[3]
    processes = int(sys.argv[4])

    # 读取文件并处理数据
    c1 = []
    c2 = []
    c3 = []
    with open(f1_filename) as file1, open(f2_filename) as file2:
        for line_num, (line1, line2) in enumerate(zip(file1, file2)):
            if line_num % 4 == 1:
                c1.append(line1.strip())
                c2.append(line2.strip())
            elif line_num % 4 == 0:
                c3.append(line1.split()[0])

    merged_list = [f"{elem1} {elem2}" for elem1, elem2 in zip(c1, c2)]
    merged_list2 = [f"{elem1} {elem2}" for elem1, elem2 in zip(c3, merged_list)]

    # 创建进程池，可以指定进程数，默认使用 CPU 核心数
    pool = multiprocessing.Pool(processes=processes)
    # 并行处理每个字符串
    processed_strings = pool.map(process_reads, merged_list2)
    # 关闭进程池
    pool.close()
    pool.join()
    # 将所有处理后的字符串保存到文件中
    with open(out_filename, 'w') as f:
        for s in processed_strings:
            lenth=len(s.split()[1])
            if lenth>49:
                f.write(s.split()[0]+ '\n'+s.split()[1]+'\n'+"+"+'\n'+'I' * lenth +'\n')
